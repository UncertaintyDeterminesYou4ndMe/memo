# linux 命令行操作

## 三大重要命令
### sed
-1 举例
```
echo "a.\`曝光UV\`,
a.\`曝光PV\`,
a.\`点击UV\`,
a.\`点击PV\`,
a.\`完成UV\`,
a.\`完成PV\`,
a.\`领取UV\`,
a.\`领取PV\`," | sed "s/\(a\.`[^`]*`\)/SUM(\1) AS \1/g"
```
-2 解释
```
```bash
sed "s/\(a\.`[^`]*`\)/SUM(\1) AS \1/g"
```

- `sed`: 是一个流编辑器，可以对来自标准输入或文件的文本进行基本的文本转换。
- `"s/.../.../g"`: 这是 `sed` 的替换命令。它尝试将匹配的模式（第一个 `/.../` 之间的部分）替换为指定的文本（第二个 `/.../` 之间的部分）。`g` 表示全局替换，即在每一行中替换所有匹配的实例，而不只是第一个。
- `\(a\.`[^`]*`\)\`: 这是正则表达式的一部分，用于匹配文本。让我们分解这个表达式：
  - `\(` 和 `\)\`: 这些是捕获组的标记。它们告诉 `sed` 记住这些括号中匹配的文本，以便稍后可以在替换文本中引用。
  - `a\.`: 匹配字母 `a` 后跟一个点 `.`。反斜杠 `\` 是转义字符，用于匹配实际的点字符，因为在正则表达式中点有特殊含义（匹配任何单个字符）。
  - ``[^`]*``: 这是一个字符类，匹配不是反引号 `` ` `` 的任何字符。星号 `*` 表示匹配前面的字符类零次或多次。
  - `` ` ``: 匹配实际的反引号字符。
- `SUM(\1) AS \1`: 这是替换文本。`\1` 引用了之前由捕获组 `\( ... \)` 捕获的文本。因此，每个匹配的列名都被替换为 `SUM(列名) AS 列名` 的形式。
```
