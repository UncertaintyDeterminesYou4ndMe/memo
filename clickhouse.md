## 二十九、Clickhouse

联机分析(OLAP)的列式数据库管理系统(DBMS)。能够使用SQL查询实时生成分析数据报告。它同样拥有优秀的数据存储能力。

优点：OLAP 查询快

缺点：join不友好

|          | Hbase                                                   | Kudu                                                  | Clickhouse                                    |
| -------- | ------------------------------------------------------- | ----------------------------------------------------- | --------------------------------------------- |
| 数据存储 | Zookeeper保存元数据，数据写入HDFS(非结构化数据)         | master保存元数据，数据及副本存储在tserver(强类型数据) | Zookeeper保存元数据，数据存储在本地，且会压缩 |
| 查询     | 查询比较麻烦，Phoenix集成之后比较好点                   | 查询比较麻烦，集成Impala之后表现优秀                  | 高效的查询能力                                |
| 数据读写 | 支持随机读写，删除。更新操作是插入一条新timestamp的数据 | 支持读写，删除，更新                                  | 支持读写，但不能删除和更新                    |
| 维护     | 需要同时维护HDFS、Zookeeper和Hbase(甚至于Phoenix)       | CDH版本维护简单，Apache版需要单独维护，额外还有Impala | 额外维护Zookeeper                             |

* Hbase更适合非结构化的数据存储；

* 在既要求随机读写又要求实时更新的场景，Kudu+Impala可以很好的胜任，当然再结合CDH就更好了，瓶颈并不在Kudu，而在Impala的Apache部署，特别麻烦。详见 Apache集群安装Impala；

* 如果只要求静态数据的极速查询能力，Clickhouse则更好。

> **优点：**
>
> 1，为了高效的使用CPU，数据不仅仅按列存储，同时还按向量进行处理；
>
> 2，数据压缩空间大，减少IO；处理单查询高吞吐量每台服务器每秒最多数十亿行；
>
> 3，索引非B树结构，不需要满足最左原则；只要过滤条件在索引列中包含即可；即使在使用的数据不在索引中，由于各种并行处理机制ClickHouse全表扫描的速度也很快；
>
> 4，写入速度非常快，50-200M/s，对于大量的数据更新非常适用。
>
> **缺点：**
>
> 1，不支持事务，不支持真正的删除/更新；
>
> 2，不支持高并发，官方建议qps为100，可以通过修改配置文件增加连接数，但是在服务器足够好的情况下；
>
> 3，SQL满足日常使用80%以上的语法，join写法比较特殊；最新版已支持类似SQL的join，但性能不好；
>
> 4，尽量做1000条以上批量的写入，避免逐行insert或小批量的insert，update，delete操作，因为ClickHouse底层会不断的做异步的数据合并，会影响查询性能，这个在做实时数据写入的时候要尽量避开；
>
> 5，Clickhouse快是因为采用了并行处理机制，即使一个查询，也会用服务器一半的CPU去执行，所以ClickHouse不能支持高并发的使用场景，默认单查询使用CPU核数为服务器核数的一半，安装时会自动识别服务器核数，可以通过配置文件修改该参数。
>
> 全量数据导入：数据导入临时表 -> 导入完成后，将原表改名为tmp1 -> 将临时表改名为正式表 -> 删除原表
>
> 增量数据导入： 增量数据导入临时表 -> 将原数据除增量外的也导入临时表 -> 导入完成后，将原表改名为tmp1-> 将临时表改成正式表-> 删除原数据表
>
> **优化：**
>
> 1，关闭虚拟内存，物理内存和虚拟内存的数据交换，会导致查询变慢。
>
> 2，为每一个账户添加join_use_nulls配置，左表中的一条记录在右表中不存在，右表的相应字段会返回该字段相应数据类型的默认值，而不是标准SQL中的Null值。
>
> 3，JOIN操作时一定要把数据量小的表放在右边，ClickHouse中无论是Left Join 、Right Join还是Inner Join永远都是拿着右表中的每一条记录到左表中查找该记录是否存在，所以右表必须是小表。
>
> 4，批量写入数据时，必须控制每个批次的数据中涉及到的分区的数量，在写入之前最好对需要导入的数据进行排序。无序的数据或者涉及的分区太多，会导致ClickHouse无法及时对新导入的数据进行合并，从而影响查询性能。
>
> 5，尽量减少JOIN时的左右表的数据量，必要时可以提前对某张表进行聚合操作，减少数据条数。有些时候，先GROUP BY再JOIN比先JOIN再GROUP BY查询时间更短。
>
> 6，ClickHouse的分布式表性能性价比不如物理表高，建表分区字段值不宜过多，防止数据导入过程磁盘可能会被打满。
>
> 7，CPU一般在50%左右会出现查询波动，达到70%会出现大范围的查询超时，CPU是最关键的指标，要非常关注。
>
> **性能情况**
>
> 1,单个查询吞吐量：如果数据被放置在page cache中，则一个不太复杂的查询在单个服务器上大约能够以2-10GB／s（未压缩）的速度进行处理（对于简单的查询，速度可以达到30GB／s）。如果数据没有在page cache中的话，那么速度将取决于你的磁盘系统和数据的压缩率。例如，如果一个磁盘允许以400MB／s的速度读取数据，并且数据压缩率是3，则数据的处理速度为1.2GB/s。这意味着，如果你是在提取一个10字节的列，那么它的处理速度大约是1-2亿行每秒。对于分布式处理，处理速度几乎是线性扩展的，但这受限于聚合或排序的结果不是那么大的情况下。
>
> 2，处理短查询的延时时间：数据被page cache缓存的情况下，它的延迟应该小于50毫秒(最佳情况下应该小于10毫秒)。 否则，延迟取决于数据的查找次数。延迟可以通过以下公式计算得知： 查找时间（10 ms） * 查询的列的数量 * 查询的数据块的数量。
>
> 3，处理大量短查询：ClickHouse可以在单个服务器上每秒处理数百个查询（在最佳的情况下最多可以处理数千个）。但是由于这不适用于分析型场景。建议每秒最多查询100次。
>
> 4，数据写入性能：建议每次写入不少于1000行的批量写入，或每秒不超过一个写入请求。当使用tab-separated格式将一份数据写入到MergeTree表中时，写入速度大约为50到200MB/s。如果您写入的数据每行为1Kb，那么写入的速度为50，000到200，000行每秒。如果您的行更小，那么写入速度将更高。为了提高写入性能，您可以使用多个INSERT进行并行写入，这将带来线性的性能提升。
>
> count: 千万级别，500毫秒，1亿 800毫秒  2亿 900毫秒 3亿 1.1秒
> group: 百万级别 200毫米，千万 1秒，1亿 10秒，2亿 20秒，3亿 30秒
> join：千万-10万 600 毫秒， 千万 -百万：10秒，千万-千万 150秒
>
> ClickHouse并非无所不能，查询语句需要不断的调优，可能与查询条件有关，不同的查询条件表是左join还是右join也是很有讲究的。
>
> 其他补充：
>
> 1，MySQL单条SQL是单线程的，只能跑满一个core，ClickHouse相反，有多少CPU，吃多少资源，所以飞快；
> 2，ClickHouse不支持事务，不存在隔离级别。ClickHouse的定位是分析性数据库，而不是严格的关系型数据库。
> 3，IO方面，MySQL是行存储，ClickHouse是列存储，后者在count()这类操作天然有优势，同时，在IO方面，MySQL需要大量随机IO，ClickHouse基本是顺序IO。
> 有人可能觉得上面的数据导入的时候，数据肯定缓存在内存里了，这个的确，但是ClickHouse基本上是顺序IO。对IO基本没有太高要求，当然，磁盘越快，上层处理越快，但是99%的情况是，CPU先跑满了（数据库里太少见了，大多数都是IO不够用）
>
> 
